06/16 

##Interface

• 일반적으로 변수, 함수, 클래스에 타입 체크를 위해 사용된다.
• 직접 인스턴스를 생성할 수 없고 모든 메소드가 추상 메소드이다.
• 추상 클래스의 추상 메소드와 달리 abstract 키워드는 사용할 수 없다.
• ES6는 인터페이스를 지원하지 않지만 TypeScript는 인터페이스를 지원한다.



##Properties

1. Optional Properties
프로퍼티 선언 시 이름 끝에 ?를 붙여서 표시한다.
• 인터페이스에 속하지 않는 프로퍼티의 사용을 방지하면서, 사용 가능한 프로퍼티를 기술할 때 사용한다.
• 객체 안의 몇 개의 프로퍼티만 채워 함수에 전달하는 "option bags" 같은 패턴에 유용하다.
• 해당 프로퍼티가 존재하지 않더라도 컴파일 에러가 발생하지 않는다.

2. Readonly properties
• 객체가 처음 생성될 때만 값 설정이 가능하고, 이후 수정이 불가능하다.
• 프로퍼티 이름 앞에 readonly를 붙여 사용한다.
• readonly PROPERTY: TYPE과 같이 사용한다.

3. readonly vs const
• readonly와 const의 공통점 : 생성 후에 배열을 변경하지 않음을 보장한다.
• 변수는 const를 사용하고 프로퍼티는 readonly를 사용한다.

##interface types

1. function type
• 함수의 인자의 타입과 반환 값의 타입을 정의한다.
• 함수의 타입을 정의할 때에도 사용한다.

2. class type
• 클래스가 특정 계약(contract)을 충족하도록 명시적으로 강제한다.

3. interface 확장
• 클래스와 마찬가지로 인터페이스도 인터페이스 간의 확장이 가능하다.

4. hybrid type
• 자바스크립트의 유연하고 동적인 타입 특성에 따라 인터페이스 역시 여러 가지 타입을 조합할 수 있다.
• 아래 코드와 같이, 함수 타입이면서 객체 타입을 정의할 수 있는 인터페이스도 구현할 수 있다.

interface를 활용한 디자인 패턴 (Strategy pattern)
• 객체가 할 수 있는 행위들을 전략(strategy)으로 만들어두고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것 만으로 수정이 가능하도록 만든 패턴이다.

##Generic
• 정적  type 언어는  클래스나  함수를  정의할  때  type을  선언해야  한다.
ex) C 언어는  int type 변수를  선언하면  정수형  값만  할당할  수  있다.
• Generic은 코드를 작성할 때가 아니라 코드가 수행될 때 타입을 명시한다.
• 코드를  작성할  때  식별자를  써서  아직  정해지지  않은  타입을  표시한다.
일반적으로  식별자는  T, U, V, ...를  사용한다. 
필드  이름의  첫  글자를  사용하기도  한다.

##Union type
• Union type “|”를  사용해  두  개  이상의  타입을  선언하는  방식
• Union과 Generic 모두 여러 타입을 다룰 수 있다.
Union은  선언한  공통된  메소드만  사용할  수  있다.
리턴  값이  하나의  타입이  아닌  선언된  Union 타입으로  지정된다.

##제약조건(Constraints / keyof) 
• 원하지 않는 속성에 접근하는 것을 막기 위해 Generic에 제약조건을 사용한다.
1.  Constraints : 특정  타입들로만  동작하는  Generic 함수를  만들  때  사용한다.
•  Generic T에  제약  조건을  설정한다. (문자열  or 숫자)
• 제약 조건을 벗어나는 타입을 선언하면 에러가 발생한다.

2.  Keyof : 키 타입을 얻기 위해서
• 두번째  함수에서  오류가  발생한다.
• Generic T는  키  값이  a, b, c만  존재하는  object이다.
• U의 값인 ‘z’ 가 Generic T의 키 값 중 존재하지 않기 때문에 오류가 발생한다.
typeof : 객체 데이터를 객체 타입으로 변환해주는 연산자
keyof : 객체 형태의 타입을, 따로 속성들만 뽑아 모아 유니온 타입으로 만들어주는 연산자

##Factory Pattern with Generics     
• 객체를  생성하는  인터페이스만  미리  정의하고,
인스턴스를  만들  클래스의  결정은  서브  클래스가  내리는  패턴
• 여러  개의  서브  클래스를  가진  슈퍼  클래스가  있을  때, 
입력에  따라  하나의  서브  클래스의  인스턴스를  반환한다.            

--------------------------------------------------------------
헷갈린부분 

implements :인터페이스를 구현할 때 사용합니다. 인터페이스는 클래스가 특정한 메서드나 속성을 구현하도록 강제하는 역할을 합니다. 클래스가 인터페이스를 implements 키워드로 구현하면, 해당 인터페이스에 정의된 모든 메서드와 속성을 구현해야 합니다.

interface Animal {
  move(): void;
}

class Dog implements Animal {
  move() {
    console.log("Dog is moving");
  }
}


extends: 클래스 간의 상속 관계를 정의할 때 사용합니다. 상속은 한 클래스가 다른 클래스의 속성과 메서드를 상속받아 사용할 수 있도록 해줍니다. 상속은 단일 상속만을 지원합니다.

class Animal {
  move() {
    console.log("Animal is moving");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Dog is barking");
  }
}


void: 타입스크립트에서 함수 또는 메서드의 반환 타입을 나타내는 키워드입니다.
함수가 void를 반환 타입으로 가지면, 해당 함수는 어떤 값을 반환하지 않음을 의미합니다. 
즉, 함수의 실행 결과로 아무런 값을 돌려주지 않습니다.

Instance: 클래스(Class)의 실제 객체를 말합니다. 클래스는 객체를 만들기 위한 설계도이고, 이 설계도를 기반으로 생성된 실체가 인스턴스입니다.


& 연산자를 이용해 여러 개의 타입 정의를 하나로 합치는 방식을 사용하면 됩니다.
interface Doctor {
  name: string;
  age: number;
}
interface Engineer {
  name: string;
  skill: string;
}

// Docter 인터페이스와 Engineer 인터페이스를 합친 타입을 선언하세요.
type Capt = Doctor & Engineer;

// 함수의 매개변수 타입을 수정하세요.
function introduce(person: Capt) {
  console.log(person.name); 
  console.log(person.age); 
  console.log(person.skill); 
}

// 채점을 위한 코드입니다. 수정하지 마세요.
export { introduce };


